<!DOCTYPE html>
<html lang="en">
  <head>
    <title>heatmap</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link type="text/css" rel="stylesheet" href="main.css">
  </head>
  <body>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "./three.module.js"
        }
      }
    </script>
    <script src = 'racks.js'></script>
    <script type="module">
//
function spectrumGreenRed(numerator, denominator) {
  let decimalBlue;
  let decimalGreen;
  let decimalRed;
  let decimal;
  let saturation;
  decimalBlue = 1;
  decimalGreen = 0;
  decimalRed = 0;
  saturation = 1;
  decimal = numerator / denominator;
  if (denominator == 0){
    decimal = 1;
  }
  if (decimal < 0) {
    decimal = 0;
  }
  if (decimal > 1) {
    decimal = 1;
  }
  // green to yellow
  if (decimal < 0.5) {
    decimalBlue = (1 - saturation);
    decimalGreen = 1;
    decimalRed = (1 - saturation) + (decimal / 0.5 * saturation);
  }
  // yellow to red
  if (decimal >= 0.5) {
    decimalBlue = (1 - saturation);
    decimalGreen = (1 - saturation) + (saturation - ((decimal - 0.5) / 0.5) * saturation);
    decimalRed = 1;
  }
  // max or over, hard red
  if (decimal >= 1.0) {
    decimalBlue = 0;
    decimalGreen = 0;
    decimalRed = 1;
  }
  return [
    decimalBlue,
    decimalGreen,
    decimalRed
  ];
}
function addRacks() {
  let boxX = 0.4;
  let boxY = 1;
  let boxZ = 0.4;
  let colorBlue = 0;
  let colorGreen = 0;
  let colorRed = 0;
  let boxGeometry;
  let boxMaterial;
  let boxMesh;
  let centerY;
  let centerZ;
  let centerX;
  let sizeX;
  let sizeY;
  let sizeZ;
  Object.keys(rackData).forEach((rackSysId) => {
    // using blender coordinates as inputs
    // the player spawns in vr on 0,0,0 facing -X
    // move whole scene negative x to appear in front of the player
    centerX = ((rackData[rackSysId].centerX - roomData.sizeX) * scale) - tableDistance;
    // move the scene negative y, half the room dimension so it is centered on the player
    centerY = (rackData[rackSysId].centerY - (roomData.sizeY * 0.5)) * scale;
    // adjust the 'table' height
    centerZ = (rackData[rackSysId].centerZ * scale) + tableHeight;
    sizeX = rackData[rackSysId].sizeX * scale;
    sizeY = rackData[rackSysId].sizeY * scale;
    sizeZ = rackData[rackSysId].sizeZ * scale;
    console.log('centerX')
    console.log(centerX)
    // console.log('centerZ')
    // console.log(centerZ)
    // @ts-ignore
    boxGeometry = new THREE.BoxGeometry(sizeY, sizeZ, sizeX);
    // @ts-ignore
    boxMaterial = new THREE.MeshStandardMaterial();
    [
      colorBlue,
      colorGreen,
      colorRed
    ] = spectrumGreenRed(Math.random(), 1);
    boxMaterial.color.setRGB(colorRed, colorGreen, colorBlue);
    boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
    boxMesh.position.x = centerY;
    boxMesh.position.y = centerZ;
    boxMesh.position.z = centerX;
    // @ts-ignore
    boxMesh.name = 'testing';
    scene.add(boxMesh);
  });
}
function init() {
  const container = document.createElement('div');
  document.body.appendChild(container);
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  // camera
  const cameraRatio = window.innerWidth / window.innerHeight;
  camera = new THREE.PerspectiveCamera(50, cameraRatio, 0.01, 50);
  camera.position.set(0, 1.0, 0);
  controls = new OrbitControls(camera, container);
  var controlX = 0 - tableDistance - (roomData.sizeX * 0.5 * scale);
  controls.target.set(0, tableHeight, controlX);
  controls.update();
  // table
  // const tableGeometry = new THREE.BoxGeometry(tableWidth, tableHeight, tableWidth);
  // const tableMaterial = new THREE.MeshStandardMaterial({
  //   color: 0x444444,
  //   roughness: 1.0,
  //   metalness: 0.0
  // });
  // const table = new THREE.Mesh(tableGeometry, tableMaterial);
  // table.position.y = (tableHeight * 0.5);
  // table.position.z = 0;
  // scene.add(table);
  // boxes
  // addBoxes();
  // floor
  // const floorGometry = new THREE.PlaneGeometry(4, 4);
  // const floorMaterial = new THREE.MeshStandardMaterial({
  //   color: 0x222222,
  //   roughness: 1.0,
  //   metalness: 0.0
  // });
  // const floor = new THREE.Mesh(floorGometry, floorMaterial);
  // floor.rotation.x = - Math.PI / 2;
  // floor.position.z = 0;
  // scene.add(floor);
  // grid
  // const grid = new THREE.GridHelper(10, 20, 0x111111, 0x111111);
  // grid.position.z = 0;
  // scene.add(grid);
  // racks
  addRacks();
  // light
  scene.add(new THREE.HemisphereLight(0x888877, 0x777788));
  const light = new THREE.DirectionalLight(0xffffff, 0.5);
  light.position.set(0, 4, 0);
  scene.add(light);
  // painters
  const painter1 = new TubePainter();
  scene.add(painter1.mesh);
  const painter2 = new TubePainter();
  scene.add(painter2.mesh);
  // renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.xr.enabled = true;
  container.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));
  function onSelectStart() {
    this.userData.isSelecting = true;
  }
  function onSelectEnd() {
    this.userData.isSelecting = false;
  }
  function onSqueezeStart() {
    this.userData.isSqueezing = true;
    this.userData.positionAtSqueezeStart = this.position.y;
    this.userData.scaleAtSqueezeStart = this.scale.x;
  }
  function onSqueezeEnd() {
    this.userData.isSqueezing = false;
  }
  controller1 = renderer.xr.getController(0);
  controller1.addEventListener('selectstart', onSelectStart);
  controller1.addEventListener('selectend', onSelectEnd);
  controller1.addEventListener('squeezestart', onSqueezeStart);
  controller1.addEventListener('squeezeend', onSqueezeEnd);
  controller1.userData.painter = painter1;
  scene.add(controller1);
  controller2 = renderer.xr.getController(1);
  controller2.addEventListener('selectstart', onSelectStart);
  controller2.addEventListener('selectend', onSelectEnd);
  controller2.addEventListener('squeezestart', onSqueezeStart);
  controller2.addEventListener('squeezeend', onSqueezeEnd);
  controller2.userData.painter = painter2;
  scene.add(controller2);
  const geometry = new THREE.CylinderGeometry(0.01, 0.02, 0.08, 5);
  geometry.rotateX(- Math.PI / 2);
  const material = new THREE.MeshStandardMaterial({ flatShading: true });
  const mesh = new THREE.Mesh(geometry, material);
  const pivot = new THREE.Mesh(new THREE.IcosahedronGeometry(0.01, 3));
  pivot.name = 'pivot';
  pivot.position.z = - 0.05;
  mesh.add(pivot);
  controller1.add(mesh.clone());
  controller2.add(mesh.clone());
  window.addEventListener('resize', onWindowResize);
}
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function handleController(controller) {
  const userData = controller.userData;
  const painter = userData.painter;
  const pivot = controller.getObjectByName('pivot');
  if (userData.isSqueezing === true) {
    const delta = (controller.position.y - userData.positionAtSqueezeStart) * 5;
    const scale = Math.max(0.1, userData.scaleAtSqueezeStart + delta);
    pivot.scale.setScalar(scale);
    painter.setSize(scale);
  }
  cursor.setFromMatrixPosition(pivot.matrixWorld);
  if (userData.isSelecting === true) {
    painter.lineTo(cursor);
    painter.update();
  } else {
    painter.moveTo(cursor);
  }
}
function animate() {
  renderer.setAnimationLoop(render);
}
function render() {
  handleController(controller1);
  handleController(controller2);
  renderer.render(scene, camera);
}
import * as THREE from 'three';
import { OrbitControls } from './OrbitControls.js';
import { TubePainter } from './TubePainter.js';
import { VRButton } from './VRButton.js';
// room dimensions in blender orientation
let roomData = {
  'sizeX': 16,
  'sizeY': 16
}
let scale = 0.04;
let tableHeight = 0.5;
let tableDistance = 0.4;
let camera;
let scene;
let renderer;
let controller1;
let controller2;
const cursor = new THREE.Vector3();
let controls;
init();
animate();
    </script>
  </body>
</html>
