<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js vr - paint</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link type="text/css" rel="stylesheet" href="main.css">
  </head>
  <body>
    <div id="info">
      <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> vr - paint
    </div>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "./three.module.js"
        }
      }
    </script>
    <script type="module">
//
function addBoxes() {
  let boxX = 0.4;
  let boxY = 1;
  let boxZ = 0.4;
  let colorBlue = 0;
  let colorGreen = 0;
  let colorRed = 0;
  let boxGeometry;
  let boxMaterial;
  let boxMesh;
  let centerY;
  let centerZ;
  let centerX;
  let sizeX;
  let sizeY;
  let sizeZ;
  let scale = 0.025;
  // using blender coordinates as inputs
  for (let xLoop = 0; xLoop < 9; xLoop += 1) {
    for (let yLoop = 0; yLoop < 12; yLoop += 1) {
      centerX = 1.0 + (xLoop * 2.0);
      centerY = 1.0 + (yLoop * 1.45);
      centerZ = 1.0;
      sizeX = 1.0;
      sizeY = 1.4;
      sizeZ = 2.0;
      // converting to three.js table
      boxX = (tableWidth * -0.5) + (centerY * scale);
      boxY = tableHeight + (centerZ * scale);
      boxZ = tableZCenter - (tableWidth * 0.5) + (centerX * scale);
      // @ts-ignore
      boxGeometry = new THREE.BoxGeometry(sizeY * scale, sizeZ * scale, sizeX * scale);
      // @ts-ignore
      boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
      boxMesh.position.x = boxX;
      boxMesh.position.y = boxY;
      boxMesh.position.z = boxZ;
      // @ts-ignore
      boxMaterial = new THREE.MeshStandardMaterial();
      colorBlue = 0.5 + (Math.random() * 0.5);
      colorGreen = 0.5 + (Math.random() * 0.5);
      colorRed = 0.5 + (Math.random() * 0.5);
      boxMaterial.color.setRGB(colorRed, colorGreen, colorBlue);
      boxMesh.name = 'testing';
      scene.add(boxMesh);
    }
  }
}
function init() {
  const container = document.createElement('div');
  document.body.appendChild(container);
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);
  // camera
  const cameraRatio = window.innerWidth / window.innerHeight;
  camera = new THREE.PerspectiveCamera(50, cameraRatio, 0.01, 50);
  camera.position.set(0, 1.8, 0);
  controls = new OrbitControls(camera, container);
  controls.target.set(0, 0.8, tableZCenter);
  controls.update();
  // table
  const tableGeometry = new THREE.BoxGeometry(tableWidth, tableHeight, tableWidth);
  const tableMaterial = new THREE.MeshStandardMaterial({
    color: 0x444444,
    roughness: 1.0,
    metalness: 0.0
  });
  const table = new THREE.Mesh(tableGeometry, tableMaterial);
  table.position.y = (tableHeight * 0.5);
  table.position.z = tableZCenter;
  scene.add(table);
  // boxes
  addBoxes();
  // floor
  const floorGometry = new THREE.PlaneGeometry(4, 4);
  const floorMaterial = new THREE.MeshStandardMaterial({
    color: 0x222222,
    roughness: 1.0,
    metalness: 0.0
  });
  const floor = new THREE.Mesh(floorGometry, floorMaterial);
  floor.rotation.x = - Math.PI / 2;
  floor.position.z = tableZCenter;
  scene.add(floor);
  // grid
  const grid = new THREE.GridHelper(10, 20, 0x111111, 0x111111);
  grid.position.z = tableZCenter;
  scene.add(grid);
  scene.add(new THREE.HemisphereLight(0x888877, 0x777788));
  // light
  const light = new THREE.DirectionalLight(0xffffff, 0.5);
  light.position.set(0, 4, tableZCenter);
  scene.add(light);
  // painters
  const painter1 = new TubePainter();
  scene.add(painter1.mesh);
  const painter2 = new TubePainter();
  scene.add(painter2.mesh);
  // renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.xr.enabled = true;
  container.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));
  function onSelectStart() {
    this.userData.isSelecting = true;
  }
  function onSelectEnd() {
    this.userData.isSelecting = false;
  }
  function onSqueezeStart() {
    this.userData.isSqueezing = true;
    this.userData.positionAtSqueezeStart = this.position.y;
    this.userData.scaleAtSqueezeStart = this.scale.x;
  }
  function onSqueezeEnd() {
    this.userData.isSqueezing = false;
  }
  controller1 = renderer.xr.getController(0);
  controller1.addEventListener('selectstart', onSelectStart);
  controller1.addEventListener('selectend', onSelectEnd);
  controller1.addEventListener('squeezestart', onSqueezeStart);
  controller1.addEventListener('squeezeend', onSqueezeEnd);
  controller1.userData.painter = painter1;
  scene.add(controller1);
  controller2 = renderer.xr.getController(1);
  controller2.addEventListener('selectstart', onSelectStart);
  controller2.addEventListener('selectend', onSelectEnd);
  controller2.addEventListener('squeezestart', onSqueezeStart);
  controller2.addEventListener('squeezeend', onSqueezeEnd);
  controller2.userData.painter = painter2;
  scene.add(controller2);
  const geometry = new THREE.CylinderGeometry(0.01, 0.02, 0.08, 5);
  geometry.rotateX(- Math.PI / 2);
  const material = new THREE.MeshStandardMaterial({ flatShading: true });
  const mesh = new THREE.Mesh(geometry, material);
  const pivot = new THREE.Mesh(new THREE.IcosahedronGeometry(0.01, 3));
  pivot.name = 'pivot';
  pivot.position.z = - 0.05;
  mesh.add(pivot);
  controller1.add(mesh.clone());
  controller2.add(mesh.clone());
  window.addEventListener('resize', onWindowResize);
}
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function handleController(controller) {
  const userData = controller.userData;
  const painter = userData.painter;
  const pivot = controller.getObjectByName('pivot');
  if (userData.isSqueezing === true) {
    const delta = (controller.position.y - userData.positionAtSqueezeStart) * 5;
    const scale = Math.max(0.1, userData.scaleAtSqueezeStart + delta);
    pivot.scale.setScalar(scale);
    painter.setSize(scale);
  }
  cursor.setFromMatrixPosition(pivot.matrixWorld);
  if (userData.isSelecting === true) {
    painter.lineTo(cursor);
    painter.update();
  } else {
    painter.moveTo(cursor);
  }
}
function animate() {
  renderer.setAnimationLoop(render);
}
function render() {
  handleController(controller1);
  handleController(controller2);
  renderer.render(scene, camera);
}
import * as THREE from 'three';
import { OrbitControls } from './OrbitControls.js';
import { TubePainter } from './TubePainter.js';
import { VRButton } from './VRButton.js';
let tableZCenter = -0.5;
let tableHeight = 0.7;
let tableWidth = 0.5;
let camera;
let scene;
let renderer;
let controller1;
let controller2;
const cursor = new THREE.Vector3();
let controls;
init();
animate();
    </script>
  </body>
</html>
